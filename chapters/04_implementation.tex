\chapter{Implementation}
\label{ch:impl}
% TODO which files needed to be modified, change in settings
% TODO changes only necessary in python code

\section{DIIS}
% TODO linmix already existed as a starting point

\begin{lstlisting}[label=lst:diis, language=python, caption=DIIS implementation]
import numpy as np
from numpy.linalg import multi_dot

class DiisMixer(object):
  def __init__(self, oldshare, history, period):
    self.alpha = 1 - oldshare
    self.history = history
    self.period = period
    
    self.i = 0
    self.trials = []
    self.residuals = []

  def __call__(self, new_value):
    if self.i == 0:
      # no history yet
      result = new_value
    else:
      trial = self.trials[-1]
      residual = new_value - trial
      self.residuals.append(residual)
      
      # trim history
      self.trials = self.trials[:self.history]
      self.residuals = self.residuals[:self.history]
      
      if self.i <= 2 or (self.i % self.period) != 0:
        # linear mixing
        result = trial + self.alpha * residual
      else:
        # pulay mixing
        R = np.array(self.trials); R = R[1:] - R[:-1]; R = R.T
        F = np.array(self.residuals); F = F[1:] - F[:-1]; F = F.T
        result = trial + self.alpha * residual - multi_dot([
            R + self.alpha * F, np.linalg.pinv(F), residual])
        
        self.i += 1
        self.trials.append(result)
        return result
\end{lstlisting}

This DIIS mixing implementation works with real vectors. It is similar to the periodic Pulay method\cite{diis_periodic}. The most significant difference is the use of the pseudo inverse which exists if \(F_k^\dagger F_k\) is not invertible.

\section{Refactor}
% TODO why refactor and what -> mix all quantities in one step -> why
% TODO explain/cite decorator pattern and why it fits

The quantities we want to mix are not vectors but higher dimensional objects with complex numbers. To use our DIIS implementation in this case, we can naively reshape the data to a vector and seperate the real and imaginary part of the complex numbers. This functionality was implemented with the Decorator pattern.

\begin{lstlisting}[label=lst:flatdec, language=python, caption=Flat mixing decorator]
import w2dyn.auxiliaries.deepflatten as deepflatten

class FlatMixingDecorator(object):
  def __init__(self, mixer):
    self.mixer = mixer
  def __call__(self, *args):
    if len(args) == 1: args = args[0]
    types = deepflatten.types(args)
    shape = deepflatten.shape(args)
    x = deepflatten.flatten(args)
    x = self.mixer(x)
    x = deepflatten.restore(x, shape, types)
    return x
\end{lstlisting}

\begin{lstlisting}[label=lst:realdec, language=python, caption=Real mixing decorator]
import numpy as np

class RealMixingDecorator(object):
  def __init__(self, mixer):
    self.mixer = mixer
  def __call__(self, x):
    n = x.shape[0]
    x = np.concatenate([np.real(x), np.imag(x)])
    x = self.mixer(x)
    x = x[:n] + 1j*x[n:]
    return x
\end{lstlisting}

\section{Deep flatten}
% TODO why deep flatten -> input is a mix of numbers, python lists and numpy arrays with different data types -> generalization desireable to avoid input constraints (wide contract)
% TODO explain functions, mention recursion caused by nested lists

\begin{lstlisting}[label=lst:deepflat, language=python, caption=deepflatten.py]
import numbers
import numpy as np

def types(x):
  if type(x) is np.ndarray: return x.dtype
  if isinstance(x, numbers.Number): return type(x)
  result = []
  for i in x: result.append(types(i))
  return result

def shape(x):
  if type(x) is np.ndarray: return x.shape
  if isinstance(x, numbers.Number): return 1
  result = []
  for i in x: result.append(shape(i))
  return result

def flatten(x):
  if type(x) is np.ndarray: return x.flatten()
  if isinstance(x, numbers.Number): return np.array([x])
  result = np.array([])
  for i in x: result = np.append(result, flatten(i))
  return result

def restore(x, shape, types):
  def recursive(x, shape, types):
    if isinstance(shape, tuple):
      size = np.prod(shape)
      return x[:size].reshape(shape).astype(types), size
    if shape == 1:
      return types(x[0]), 1
    result = []
    offset = 0
    for s, t in zip(shape, types):
      tmp = recursive(x[offset:], s, t)
      result.append(tmp[0])
      offset += tmp[1]
    return result, offset
  return recursive(x, shape, types)[0]
\end{lstlisting}

