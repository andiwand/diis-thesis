\chapter{Implementation}
\label{ch:impl}

\section{DIIS}

\begin{lstlisting}[label=lst:diis, language=python, caption=DIIS implementation]
class DiisMixer(object):
    def __init__(self, oldshare, history, period):
        self.alpha = 1 - oldshare
        self.history = history
        self.period = period

        self.i = 0
        self.trials = []
        self.residuals = []

    def __call__(self, new_value):
        if self.i == 0:
            # no history yet
            result = new_value
        else:
            trial = self.trials[-1]
            residual = new_value - trial
            self.residuals.append(residual)

            # trim history
            self.trials = self.trials[:self.history]
            self.residuals = self.residuals[:self.history]

            if self.i <= 2 or (self.i % self.period) != 0:
                # linear mixing
                result = trial + self.alpha * residual
            else:
                # pulary mixing
                R = np.array(self.trials); R = R[1:] - R[:-1]; R = R.T
                F = np.array(self.residuals); F = F[1:] - F[:-1]; F = F.T
                result = trial + self.alpha * residual \
                         - np.linalg.multi_dot([R + self.alpha * F, np.linalg.pinv(F), residual])

        self.i += 1
        self.trials.append(result)
        return result
\end{lstlisting}

% TODO why pinv? -> equality but also exists if not invertible
This DIIS mixing implementation works with real vectors. It is similar to the periodic Pulay method\cite{diis_periodic}. The most significant difference is the use of the pseudo inverse.

\section{Refactor}
% TODO mention or show linear mixing refactor?

% TODO why refactor and what -> mix all quantities in one step -> why
blabla

% TODO explain/cite decorator pattern and why it fits
The quantities we want to mix are not vectors but higher dimensional objects with complex numbers. To use our DIIS implementation in this case, we can naively reshape the data to a vector and seperate the real and imaginary part of the complex numbers. This functionality was implemented with the Decorator pattern.

\begin{lstlisting}[label=lst:flatdec, language=python, caption=Flat mixing decorator]
class FlatMixingDecorator(object):
    def __init__(self, mixer):
        self.mixer = mixer
    def __call__(self, *args):
        if len(args) == 1: args = args[0]
        types = deepflatten.types(args)
        shape = deepflatten.shape(args)
        x = deepflatten.flatten(args)
        x = self.mixer(x)
        x = deepflatten.restore(x, shape, types)
        return x
\end{lstlisting}

\begin{lstlisting}[label=lst:realdec, language=python, caption=Real mixing decorator]
class RealMixingDecorator(object):
    def __init__(self, mixer):
        self.mixer = mixer
    def __call__(self, x):
        n = x.shape[0]
        x = np.concatenate([np.real(x), np.imag(x)])
        x = self.mixer(x)
        x = x[:n] + 1j*x[n:]
        return x
\end{lstlisting}

\section{Deep flatten}
% TODO why deep flatten -> input is a mix of numbers, python lists and numpy arrays with different data types -> generalization desireable to avoid input constraints (wide contract)
% TODO explain functions, mention recursion caused by nested lists

% TODO move to appendix?
\begin{lstlisting}[label=lst:deepflat, language=python, caption=deepflatten.py]
import numbers
import numpy as np

def types(x):
    if type(x) is np.ndarray: return x.dtype
    if isinstance(x, numbers.Number): return type(x)
    result = []
    for i in x: result.append(types(i))
    return result

def shape(x):
    if type(x) is np.ndarray: return x.shape
    if isinstance(x, numbers.Number): return 1
    result = []
    for i in x: result.append(shape(i))
    return result

def flatten(x):
    if type(x) is np.ndarray: return x.flatten()
    if isinstance(x, numbers.Number): return np.array([x])
    result = np.array([])
    for i in x: result = np.append(result, flatten(i))
    return result

def restore(x, shape, types):
    def recursive(x, shape, types):
        if isinstance(shape, tuple):
            size = np.prod(shape)
            return x[:size].reshape(shape).astype(types), size
        if shape == 1:
            return types(x[0]), 1
        result = []
        offset = 0
        for s, t in zip(shape, types):
            tmp = recursive(x[offset:], s, t)
            result.append(tmp[0])
            offset += tmp[1]
        return result, offset
    return recursive(x, shape, types)[0]
\end{lstlisting}

